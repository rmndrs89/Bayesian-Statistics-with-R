# Location and scale mixture of AR model

## Earthquakes data

```{r}
#| label: fig-google-time-series
#| fig-cap: Time series of observed Google search indexes.

covid.dat <- read.delim("./data/GoogleSearchIndex.txt")
covid.dat$Week=as.Date(as.character(covid.dat$Week),format = "%Y-%m-%d")

y.dat=covid.dat$covid[1:57] ## this is the training data
y.new=covid.dat$covid[58:60] ## this is the test data

plot.ts(
  y.dat,
  ylab = expression(italic(y)[italic(t)]),
  xlab = expression(italic(t)),
  main = ""
)
```

## Setting the prior

We will fit a two-component AR(1) mixture. That is, $p = 1$ and $K = 2$. Firstly, we set up the model by choosing prior hyperparameters. We use weakly informative priors for all parameters. That is, we set $a_{1} = a_{2} = 1$, $\mathbf{m}_{0} = \left(0 \right)$, $\mathbf{C}_{0} = 10$, and $n_{0} = d_{0} = 0.02$. They are specified using the following code:

```{r}
library(MCMCpack)
library(mvtnorm)

p = 1  # order of AR process
K = 2  # number of components

Y = matrix(y.dat[(p+1):length(y.dat)], ncol = 1)  # y_{p+1:T}
Fmtx = matrix(
  c(
    y.dat[1:(length(y.dat)-1)]
  ),
  nrow = 1, 
  byrow = TRUE
)  # design matrix F
n = length(Y)  # T - p

## Prior hyperparameters
m0 = 0
C0 = 10
n0 = 2
d0 = 2
a = rep(1, K)
```

## Sampling functions

Now we define the sampling function for all the parameters, using the posterior full conditional distribution we have derived.

```{r}
sample_omega = function(L.cur){
  n.vec = table(factor(L.cur, levels=1:2))
  rdirichlet(1, a + n.vec)
}

sample_L = function(y, x, phi.cur, omega.cur, nu.cur){

  L.new = numeric(length(y))

  for (t in 1:length(y)) {

    logp = sapply(1:2, function(k){
      log(omega.cur[k]) +
        dnorm(y[t],
              mean = phi.cur[k] * x[t],
              sd = sqrt(nu.cur[k]),
              log = TRUE)
    })

    logp = logp - max(logp)
    p = exp(logp)
    p = p / sum(p)

    L.new[t] = sample(1:2, 1, prob=p)
  }

  L.new
}

sample_nu = function(k, L.cur, phi.cur, y, x){

  idx = (L.cur == k)
  n.k = sum(idx)

  if(n.k == 0){
    shape = n0/2
    rate  = d0/2
  } else {
    resid = y[idx] - phi.cur[k] * x[idx]
    shape = (n0 + n.k)/2
    rate  = (d0 + sum(resid^2))/2
  }

  g = rgamma(1, shape=shape, rate=rate)
  g = max(g, 1e-12)   # prevent Inf
  1/g
}

sample_phi = function(k, L.cur, nu.cur, y, x){

  idx = (L.cur == k)
  n.k = sum(idx)

  if(n.k == 0){
    return(rnorm(1, m0, sqrt(C0)))
  }

  xk = x[idx]
  yk = y[idx]
  nu = nu.cur[k]

  C.k = 1 / (1/C0 + sum(xk^2)/nu)
  m.k = C.k * (m0/C0 + sum(xk*yk)/nu)

  rnorm(1, m.k, sqrt(C.k))
}
```

## Initial values
```{r}
## Set initial values
beta.cur = rep(0, p * K)
L.cur = rep(1, n)
omega.cur = rep(1 / K, K)
nu.cur = rep(1, K)

## Define placeholders to track values over time
nsim = 10e3
phi.mtx = matrix(0, nrow = p * K, ncol = nsim)
L.mtx = matrix(0, nrow = n, ncol = nsim)
omega.mtx = matrix(0, nrow = K, ncol = nsim)
nu.mtx = matrix(0, nrow = K, ncol = nsim)
```

## Sampler

```{r}
## Gibbs sampler
set.seed(123)

nsim = 10000

phi.cur = c(0,0)
nu.cur  = c(1,1)
omega.cur = c(0.5,0.5)
L.cur = sample(1:2, n, replace=TRUE)

for(i in 1:nsim){

  # omega
  omega.cur = sample_omega(L.cur)
  omega.mtx[,i] = omega.cur

  # L
  L.cur = sample_L(Y, Fmtx, phi.cur, omega.cur, nu.cur)
  L.mtx[,i] = L.cur

  # nu
  nu.cur = sapply(1:2, function(k)
    sample_nu(k, L.cur, phi.cur, Y, Fmtx))
  nu.mtx[,i] = nu.cur
  
  # phi
  phi.cur = sapply(1:2, function(k)
    sample_phi(k, L.cur, nu.cur, Y, Fmtx))
  phi.mtx[,i] = phi.cur
}
```

## Posterior check

```{r}
sample.select.idx = seq(5001, 10000, by = 1)

post.pred.y.mix = function(idx) {

  L.use   = L.mtx[, idx]      # n × 1
  phi.use = phi.mtx[, idx]    # 2 × 1
  nu.use  = nu.mtx[, idx]     # 2 × 1

  y.pred = numeric(n)

  for (t in 1:n) {

    k = L.use[t]

    mu = phi.use[k] * Fmtx[t]
    sd = sqrt(nu.use[k])

    y.pred[t] = rnorm(1, mu, sd)
  }

  y.pred
}

y.post.pred.sample = sapply(sample.select.idx, post.pred.y.mix)

summary.vec95 = function(vec) {
  c(unname(quantile(vec, 0.025)), mean(vec), unname(quantile(vec, 0.975)))
}

summary.y = apply(y.post.pred.sample, 1, summary.vec95)

plot(Y, type='b', xlab='Time', ylab='', pch=16)

lines(summary.y[2,], type='b', col='grey', lty=2, pch=4)
lines(summary.y[1,], type='l', col='purple', lty=3)
lines(summary.y[3,], type='l', col='purple', lty=3)

legend(
  "topright",
  legend=c('Truth','Mean','95% C.I.'),
  lty=1:3,
  col=c('black','grey','purple'),
  horiz = TRUE,
  pch=c(16,4,NA)
)
```

