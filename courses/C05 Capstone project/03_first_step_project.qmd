# AR model fitting example

## Bayesian conjugate analysis

### Earthquakes data
For the earthquake data, perform a conjugate Bayesian analysis of AR(2) model to the data. Using priors $\mathbf{m}_{0} = \begin{bmatrix} 0 & 0\end{bmatrix}^{\top}$, $\mathbf{C}_{0} = 10 \mathbf{I}_{2}$, and $n_{0} = d_{0} = 0.02$. Simulate 5000 posterior samples of $\nu$, $\phi_{1}$, and $\phi_{2}$ and use these 5000 posterior samples to perform posterior inference.

What is the posterior mean estimate of two AR coefficients and the variance parameter for the noise term? 
```{r}
earthquakes.dat <- read.delim("./data/earthquakes.txt")
earthquakes.dat$Quakes = as.numeric(earthquakes.dat$Quakes)


y.dat=earthquakes.dat$Quakes[1:100] ## this is the training data
y.new=earthquakes.dat$Quakes[101:103] ## this is the test data

plot.ts(
  y.dat,
  ylab = expression(italic(y)[italic(t)]),
  xlab = expression(italic(t)),
  main = ""
)
```

### Posterior inference

We sample 5000 sets of ($\phi_{1}$, $\phi_{2}$, $\nu$) from their marginal posterior distributions and plot them.

```{r}
library(mvtnorm)

## set up
p = 2  ## order of AR process
n.all = length(y.dat) ## T, total number of data

Y = matrix(y.dat[3:n.all], ncol = 1)
Fmtx = matrix(c(y.dat[2:(n.all-1)], y.dat[1:(n.all-2)]), nrow=p, byrow=TRUE)
n = length(Y)

## define the priors
m0 = matrix(rep(0,p),ncol=1)
C0 = diag(p)
n0 = 0.02
d0 = 0.02

e=Y-t(Fmtx)%*%m0
Q=t(Fmtx)%*%C0%*%Fmtx+diag(n)
Q.inv=chol2inv(chol(Q))
A=C0%*%Fmtx%*%Q.inv
m=m0+A%*%e
C=C0-A%*%Q%*%t(A)
n.star=n+n0
d.star=t(Y-t(Fmtx)%*%m0)%*%Q.inv%*%(Y-t(Fmtx)%*%m0)+d0


## sample from joint posterior distribution
n.sample = 5000

nu.sample = rep(0, n.sample)
phi.sample = matrix(0, nrow = n.sample, ncol = p)

for (i in 1:n.sample) {
  set.seed(i)
  nu.new = 1/rgamma(1, shape = n.star/2, rate = d.star/2)
  nu.sample[i] = nu.new
  phi.new = rmvnorm(1, mean = m, sigma = nu.new * C)
  phi.sample[i,] = phi.new
}

par(mfrow=c(1,3))
hist(phi.sample[,1],freq=FALSE,xlab=expression(phi[1]),main="",ylim=c(0,6.4))
lines(density(phi.sample[,1]),type='l',col='red')
hist(phi.sample[,2],freq=FALSE,xlab=expression(phi[2]),main="",ylim=c(0,6.4))
lines(density(phi.sample[,2]),type='l',col='red')
hist(nu.sample,freq=FALSE,xlab=expression(nu),main="")
lines(density(nu.sample),type='l',col='red')
```

### Model checking by in-sample prediction and interval estimation

To check whether the model fits well, we plot the posterior point and interval estimate for each point.

```{r}
## get in sample prediction
post.pred.y=function(s){
  
  beta.cur=matrix(phi.sample[s,],ncol=1)
  nu.cur=nu.sample[s]
  mu.y=t(Fmtx)%*%beta.cur
  sapply(1:length(mu.y), function(k){rnorm(1,mu.y[k],sqrt(nu.cur))})
  
  
}  

y.post.pred.sample=sapply(1:5000, post.pred.y)

## show the result
summary.vec95=function(vec){
  c(unname(quantile(vec,0.025)),mean(vec),unname(quantile(vec,0.975)))
}

summary.y=apply(y.post.pred.sample,MARGIN=1,summary.vec95)

plot(Y,type='b',xlab='Time',ylab='',pch=16)
lines(summary.y[2,],type='b',col='grey',lty=2,pch=4)
lines(summary.y[1,],type='l',col='purple',lty=3)
lines(summary.y[3,],type='l',col='purple',lty=3)
legend("topright",legend=c('Truth','Mean','95% C.I.'),lty=1:3,col=c('black','grey','purple'),
       horiz = T,pch=c(16,4,NA))
```

### Google search index data
For the earthquake data, perform a conjugate Bayesian analysis of AR(2) model to the data. Using priors $\mathbf{m}_{0} = \begin{bmatrix} 0 & 0\end{bmatrix}^{\top}$, $\mathbf{C}_{0} = 10 \mathbf{I}_{2}$, and $n_{0} = d_{0} = 0.02$. Simulate 5000 posterior samples of $\nu$, $\phi_{1}$, and $\phi_{2}$ and use these 5000 posterior samples to perform posterior inference.

What is the posterior mean estimate of two AR coefficients and the variance parameter for the noise term? 
```{r}
## read data, you need to make sure the data file is in your current working directoryÂ 
covid.dat <- read.delim("./data/GoogleSearchIndex.txt")
covid.dat$Week=as.Date(as.character(covid.dat$Week),format = "%Y-%m-%d")

y.dat=covid.dat$covid[1:57] ## this is the training data
y.new=covid.dat$covid[58:60] ## this is the test data

plot.ts(
  y.dat,
  ylab = expression(italic(y)[italic(t)]),
  xlab = expression(italic(t)),
  main = ""
)
```

### Posterior inference

We sample 5000 sets of ($\phi_{1}$, $\phi_{2}$, $\nu$) from their marginal posterior distributions and plot them.

```{r}
library(mvtnorm)

## set up
p = 2  ## order of AR process
n.all = length(y.dat) ## T, total number of data

Y = matrix(y.dat[3:n.all], ncol = 1)
Fmtx = matrix(c(y.dat[2:(n.all-1)], y.dat[1:(n.all-2)]), nrow=p, byrow=TRUE)
n = length(Y)

## define the priors
m0 = matrix(rep(0,p),ncol=1)
C0 = diag(p)
n0 = 0.02
d0 = 0.02

e=Y-t(Fmtx)%*%m0
Q=t(Fmtx)%*%C0%*%Fmtx+diag(n)
Q.inv=chol2inv(chol(Q))
A=C0%*%Fmtx%*%Q.inv
m=m0+A%*%e
C=C0-A%*%Q%*%t(A)
n.star=n+n0
d.star=t(Y-t(Fmtx)%*%m0)%*%Q.inv%*%(Y-t(Fmtx)%*%m0)+d0


## sample from joint posterior distribution
n.sample = 5000

nu.sample = rep(0, n.sample)
phi.sample = matrix(0, nrow = n.sample, ncol = p)

for (i in 1:n.sample) {
  set.seed(i)
  nu.new = 1/rgamma(1, shape = n.star/2, rate = d.star/2)
  nu.sample[i] = nu.new
  phi.new = rmvnorm(1, mean = m, sigma = nu.new * C)
  phi.sample[i,] = phi.new
}

par(mfrow=c(1,3))
hist(phi.sample[,1],freq=FALSE,xlab=expression(phi[1]),main="",ylim=c(0,6.4))
lines(density(phi.sample[,1]),type='l',col='red')
hist(phi.sample[,2],freq=FALSE,xlab=expression(phi[2]),main="",ylim=c(0,6.4))
lines(density(phi.sample[,2]),type='l',col='red')
hist(nu.sample,freq=FALSE,xlab=expression(nu),main="")
lines(density(nu.sample),type='l',col='red')
```

### Model checking by in-sample prediction and interval estimation

To check whether the model fits well, we plot the posterior point and interval estimate for each point.

```{r}
## get in sample prediction
post.pred.y=function(s){
  
  beta.cur=matrix(phi.sample[s,],ncol=1)
  nu.cur=nu.sample[s]
  mu.y=t(Fmtx)%*%beta.cur
  sapply(1:length(mu.y), function(k){rnorm(1,mu.y[k],sqrt(nu.cur))})
  
  
}  

y.post.pred.sample=sapply(1:5000, post.pred.y)

## show the result
summary.vec95=function(vec){
  c(unname(quantile(vec,0.025)),mean(vec),unname(quantile(vec,0.975)))
}

summary.y=apply(y.post.pred.sample,MARGIN=1,summary.vec95)

plot(Y,type='b',xlab='Time',ylab='',pch=16)
lines(summary.y[2,],type='b',col='grey',lty=2,pch=4)
lines(summary.y[1,],type='l',col='purple',lty=3)
lines(summary.y[3,],type='l',col='purple',lty=3)
legend("topright",legend=c('Truth','Mean','95% C.I.'),lty=1:3,col=c('black','grey','purple'),
       horiz = T,pch=c(16,4,NA))
```
